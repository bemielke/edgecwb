/*
 * This software is in the public domain because it contains materials 
 * that originally came from the United States Geological Survey, 
 * an agency of the United States Department of Interior. For more 
 * information, see the official USGS copyright policy at 
 * http://www.usgs.gov/visual-id/credit_usgs.html#copyright
 */
package gov.usgs.anss.net;

/**
 *
 * This Class tracks one IP address RTS status information. Instances of this class are created in
 * the UdpInside class. This class parses and takes action based on RTS status packets. Currently it
 * just mails users to notify them that a A/C status has changed. It eventually should update MySQL
 * RTS status database, and possibly provide feedback to an RTS based on other information in
 * conjuction with the RTS Status. For instance, if this class was notified of the "connection
 * status" perceived from the DMZ receivers, it could decide to order the RTS to drop a hung
 * connection.
 *
 * @author ketchum
 *
 */
import gov.usgs.anss.util.Util;
import gov.usgs.anss.util.SimpleSMTPThread;
import java.io.IOException;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import java.net.InetAddress;
import java.util.GregorianCalendar;

public final class RTSMonitor {

  private int AC;                         // last state of A/C status
  private GregorianCalendar lastUpdated;  // Last time this object was updated with a new packet
  private int numberOfPackets;            // Number of packets since the last resetNumberOfPackets 

  // Data from the dynamic packet.
  private int flags;
  private int myIP;
  private int indoy;
  private int lastrollback;
  private int rollcount;
  private int nextroll;
  private int rolling;
  private int secs_wait;
  private short delayed_detect;
  private short current_detect;
  private short indetect;
  private short max_output_rate;
  private short max_output_rate_override;
  private int data_input_bytes;
  private int data_output_bytes;
  private final int[] port_flags;
  private final short[] lastListenPort;
  private final short[] remPort;
  private final int[] remIP;
  private final int[] rxCount;
  private final int[] txCount;
  private final InetAddress IP;

  public InetAddress getAddress() {
    return IP;
  }

  public int getNumberOfPackets() {
    return numberOfPackets;
  }

  public void resetNumberOfPackets() {
    numberOfPackets = 0;
  }

  /**
   * Creates a new instance of RTSMonitor
   *
   * @param addr
   */
  public RTSMonitor(InetAddress addr) {
    IP = addr;
    port_flags = new int[16];
    lastListenPort = new short[16];
    remPort = new short[16];
    remIP = new int[16];
    rxCount = new int[16];
    txCount = new int[16];
    myIP = -1;
    AC = -1;

  }

  public void update(byte[] data) {
    makeData(data);
  }

  private void makeData(byte[] data) {
    numberOfPackets++;
    try {
      lastUpdated = new GregorianCalendar();
      DataInputStream in = new DataInputStream(new ByteArrayInputStream(data));
      for (int i = 0; i < 14; i++) {
        in.readByte(); // Skip Gomberg Header
      }
      // Read data from dataInputStream and put in our storage
      flags = in.readInt();
      int type = flags & 0xF;
      /* UDP message type 1) 
       * 0 = i*4 flags - low over 4 bits is the packet type, AC is bit 0x1000,
       * 4 = IP address as 4 bytes
       * 8 = doy as a byte
       * 9 = last rollback sequence
       * 10 = Rollback count
       * 11 = nextroll
       * 12 = secs waiting
       * 13 = delayed_detect
       */
      switch (type) {
        case 1:
          int ACnow = (flags & 0x1000) != 0 ? 1 : 0;
          if (AC != ACnow && AC != -1) {
            Util.prt("AC state change " + IP + " is " + (ACnow != 0 ? "UP" : "DOWN"));
            SimpleSMTPThread.email(Util.getProperty("emailTo"),
                    "AC is " + (ACnow != 0 ? "UP" : "DOWN") + " at " + IP, "Message is generated by UDPServer");
          }
          AC = ACnow;
          int i = in.readInt();
          if (i != myIP && myIP != -1) {
            Util.prt("Update on wrong myIP=" + myIP + " got " + i);
          }
          myIP = i;
          indoy = in.readByte() & 0xff;
          lastrollback = in.readByte() & 0xff;
          rollcount = in.readByte() & 0xff;
          nextroll = in.readByte() & 0xff;
          rolling = in.readByte() & 0xff;
          secs_wait = in.readByte() & 0xff;
          delayed_detect = in.readShort();
          current_detect = in.readShort();
          indetect = in.readShort();
          max_output_rate = in.readShort();
          max_output_rate_override = in.readShort();
          data_input_bytes = in.readInt();
          data_output_bytes = in.readInt();
          //Util.prt("flags="+flags+" IP="+myIP+" input="+data_input_bytes+" out="+data_output_bytes);
          for (i = 0; i < 48; i++) {
            in.readByte();
          }
          for (i = 0; i < 4; i++) {
            port_flags[i] = in.readInt();
            lastListenPort[i] = in.readShort();
            remPort[i] = in.readShort();
            remIP[i] = in.readInt();
            rxCount[i] = in.readInt();
            txCount[i] = in.readInt();
            //Util.prt(i+" flag="+port_flags[i]+" IP="+remIP[i]+" port="+remPort[i]+" rxCount="+rxCount[i]+" txCount="+txCount[i]);
          }
          break;
        case 2:
          Util.prt("received permanent status " + IP);
          break;
        default:
          Util.prt("Unknown status packet type =" + type + " " + IP);
      }   // End of switch on type
    } catch (IOException e) {
      Util.prt("IO execption parsing RTSMonitor :" + e.getMessage());
    }
  }
}
