/*
 * This software is in the public domain because it contains materials 
 * that originally came from the United States Geological Survey, 
 * an agency of the United States Department of Interior. For more 
 * information, see the official USGS copyright policy at 
 * http://www.usgs.gov/visual-id/credit_usgs.html#copyright
 */

/*
 * MultiChannelPanel.java
 *
 * Created on July 11, 2006, 11:42 AM
 */

package gov.usgs.edge.config;
import gov.usgs.anss.db.DBConnectionThread;
import gov.usgs.anss.gui.FlagOnOffPanel2;
import gov.usgs.anss.util.ErrorTrack;
import gov.usgs.anss.util.Show;
import gov.usgs.anss.util.Util;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;


/**
 *
 * @author  davidketchum
 */
public class StatusLogRegexpPanel extends javax.swing.JPanel {
//  FlagOnOffPanel2 sendtoPanel;
  FlagOnOffPanel2 flagsPanel;
//  FlagOnOffPanel2 linksPanel;
  Statement stmt;
  ErrorTrack err;
  int delayTime;
  boolean filewrite=false;
 
  

 // This routine must validate all fields on the form.  The err (ErrorTrack) variable
  // is used by the FUtil to verify fields.  Use FUTil or custom code here for verifications
  private boolean chkForm() {
    // Do not change
   err.reset();
   UC.Look(error);
   
   //USER:  Your error checking code goes here setting the local variables to valid settings
   // note : Use FUtil.chk* to check dates, timestamps, IP addresses, etc and put them in
   // canonical form.  store in a class variable.  For instance :
   //   sdate = FUtil.chkDate(dateTextField, err);
   // Any errors found should err.set(true);  and err.append("error message");
   Util.prt("chkForm Channel");
  
    // No CHANGES : If we found an error, color up error box
    if(err.isSet()) {
      error.setText(err.getText());
      error.setBackground(UC.red);
    }
    return err.isSet();
      
  }
  /** set initial state of screen */
  private void clearScreen() {



    
    log.setText("");
    regexpStation.setText("");
    regexpLog.setText("");
    log.setText("");
    stationnames.setText("");
    datefrom.setText("yyyy_ddd");
    dateto.setText("yyyy_ddd");

  }
  

  
  /** Creates new form MultiChannelPanel. */
  public StatusLogRegexpPanel() {
    err = new ErrorTrack();
    initComponents();

    
    Look();
    UC.Look(help);
//    UC.Look(fixed);
    clearScreen();
  }
  private void Look() {
    UC.Look(this);                    // Set color background
    
  }  
  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jScrollPane1 = new javax.swing.JScrollPane();
    help = new javax.swing.JTextArea();
    labRegexp = new javax.swing.JLabel();
    regexpStation = new javax.swing.JTextField();
    error = new javax.swing.JTextField();
    lblDateFrom = new javax.swing.JLabel();
    datefrom = new javax.swing.JTextField();
    lblDateTo = new javax.swing.JLabel();
    dateto = new javax.swing.JTextField();
    lblRegexpLog = new javax.swing.JLabel();
    regexpLog = new javax.swing.JTextField();
    jScrollPane = new javax.swing.JScrollPane();
    log = new javax.swing.JTextArea();
    jScrollPane2 = new javax.swing.JScrollPane();
    stationnames = new javax.swing.JTextPane();
    addUpdate = new javax.swing.JButton();
    writefiles = new javax.swing.JButton();

    setMaximumSize(new java.awt.Dimension(800, 800));
    setMinimumSize(new java.awt.Dimension(750, 600));
    setPreferredSize(new java.awt.Dimension(800, 800));
    setRequestFocusEnabled(false);

    jScrollPane1.setPreferredSize(new java.awt.Dimension(700, 84));

    help.setColumns(20);
    help.setEditable(false);
    help.setRows(5);
    help.setText("Instructions:\nStation: blank works for searching by dates, must enter dates, otherwise\n              use standard Regular Expression.\nDate: yyyy_ddd format - must enter From and To\nLog RegExp : will search log for this expression, blank means list everything");
    jScrollPane1.setViewportView(help);

    add(jScrollPane1);

    labRegexp.setText("Station : RegExp (or WHERE clause):");
    add(labRegexp);

    regexpStation.setText("\n");
    regexpStation.setToolTipText("station name or mask . represent single character ^start of line");
    regexpStation.setMinimumSize(new java.awt.Dimension(200, 22));
    regexpStation.setPreferredSize(new java.awt.Dimension(200, 22));
    add(regexpStation);

    error.setBackground(new java.awt.Color(192, 192, 192));
    error.setMinimumSize(new java.awt.Dimension(250, 22));
    error.setPreferredSize(new java.awt.Dimension(250, 22));
    error.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        errorActionPerformed(evt);
      }
    });
    error.addFocusListener(new java.awt.event.FocusAdapter() {
      public void focusGained(java.awt.event.FocusEvent evt) {
        errorFocus(evt);
      }
    });
    add(error);

    lblDateFrom.setText("Date - From : ");
    add(lblDateFrom);

    datefrom.setToolTipText("yyyy_doy starting date (inclusive)");
    datefrom.setMinimumSize(new java.awt.Dimension(128, 22));
    datefrom.setPreferredSize(new java.awt.Dimension(128, 22));
    add(datefrom);

    lblDateTo.setText("To : ");
    add(lblDateTo);

    dateto.setToolTipText("yyyy_doy ending date (inclusive)");
    dateto.setMinimumSize(new java.awt.Dimension(128, 22));
    dateto.setPreferredSize(new java.awt.Dimension(128, 22));
    add(dateto);

    lblRegexpLog.setText("Log RegExp (opt) : ");
    add(lblRegexpLog);

    regexpLog.setToolTipText("* zero or more characters.  ? a single character ");
    regexpLog.setPreferredSize(new java.awt.Dimension(150, 22));
    add(regexpLog);

    jScrollPane.setMaximumSize(new java.awt.Dimension(700, 300));
    jScrollPane.setMinimumSize(new java.awt.Dimension(700, 350));
    jScrollPane.setPreferredSize(new java.awt.Dimension(700, 350));

    log.setColumns(20);
    log.setEditable(false);
    log.setFont(new java.awt.Font("Courier New", 0, 13)); // NOI18N
    log.setRows(5);
    jScrollPane.setViewportView(log);

    add(jScrollPane);

    jScrollPane2.setMinimumSize(new java.awt.Dimension(700, 100));
    jScrollPane2.setPreferredSize(new java.awt.Dimension(700, 100));

    stationnames.setEditable(false);
    stationnames.setFont(new java.awt.Font("Courier", 0, 13));
    jScrollPane2.setViewportView(stationnames);

    add(jScrollPane2);

    addUpdate.setText("Search Logs");
    addUpdate.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        addUpdateActionPerformed(evt);
      }
    });
    add(addUpdate);

    writefiles.setText("Write Files");
    writefiles.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        writefilesActionPerformed(evt);
      }
    });
    add(writefiles);
  }// </editor-fold>//GEN-END:initComponents

  private void writefilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_writefilesActionPerformed
// TODO add your handling code here:
    filewrite = true;
    doRegexp();


    
  }//GEN-LAST:event_writefilesActionPerformed

  private void addUpdateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addUpdateActionPerformed
// TODO add your handling code here:
    filewrite = false;
    doRegexp();
  
  }//GEN-LAST:event_addUpdateActionPerformed

private void errorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_errorActionPerformed
// TODO add your handling code here:
  this.transferFocus();
}//GEN-LAST:event_errorActionPerformed

private void errorFocus(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_errorFocus
// TODO add your handling code here:
  this.transferFocus();
}//GEN-LAST:event_errorFocus
   /**
   * Convert a glob to a regular expression string.
   *
   * The syntax for globs is based on that of the Unix shell. '*' matches any
   * number of characters. '?' matches any single character. '[abc]' matches
   * 'a', 'b', or 'c'. '[^abc]' matches any character but 'a', 'b', and 'c'.
   * Special characters can be escaped by a backslash.
   *
   * @param glob a string containing a glob pattern
   * @return a string containing a regular expression
   * @throws IllegalArgumentException if the glob is invalid in some way
   *         (unmatched brackets, premature end of string, etc.)
   */
  private static String globToRegex(String glob)
  {
    int i;
    char c;
    int charClass;
    StringBuffer regex;

    regex = new StringBuffer();
    charClass = -1;
    if (glob.equals("")) return "*";
    for (i = 0; i < glob.length(); i++) {
      c = glob.charAt(i);
      if (c == '*') {
        regex.append(".*");
      } else if (c == '?') {
        regex.append(".");
      } else if (c == '\\') {
        i++;
        if (i >= glob.length())
          throw new IllegalArgumentException("End of string while processing '\\' at position " + (i - 1) + " in glob \"" + glob + "\"");
        c = glob.charAt(i);
        if (Character.isLetter(c))
          regex.append(c);
        else
          regex.append("\\").append(c);
      } else if (c == '[') {
        charClass = i;
        regex.append(c);
      } else if (c == ']') {
        charClass = -1;
        regex.append(c);
      } else if (c == '^' && charClass >= 0) {
        regex.append(c);
      } else if (!Character.isLetter(c)) {
        regex.append("\\").append(c);
      } else {
        regex.append(c);
      }
    }

    if (charClass >= 0)
      throw new IllegalArgumentException("End of string while reading character class that started at position " + charClass + " in glob \"" + glob + "\"");

    return regex.toString();
  }
  
  private void doRegexp() {
//    if(regexpStation.getText().equals("")) return;
    try {
      Connection C = DBConnectionThread.getConnection(DBConnectionThread.getDBSchema());
      if(stmt == null) stmt = C.createStatement();
      ResultSet rs;
      addUpdate.setText("Reading data from DB");
      String reg = regexpStation.getText();
      if (reg.length()<=0){
        rs = stmt.executeQuery("SELECT station,date,uncompress(bin) FROM status.log "
          +"WHERE date>='"+datefrom.getText()+"' AND date<='"+dateto.getText()+"' ORDER BY station,date");
      }
      else if(reg.length() >= 5 && reg.substring(0,5).equalsIgnoreCase("WHERE")) {
          rs = stmt.executeQuery("SELECT * FROM status.log "+reg+" ORDER BY station");
        }
      else {
        // NOTE: The following result set is accessed by column later, be careful when modifying
        rs = stmt.executeQuery("SELECT station,date,uncompress(bin) FROM status.log WHERE station REGEXP '"+
          reg+"' AND date>='"+datefrom.getText()+"' AND date<='"+dateto.getText()+"' ORDER BY station,date");
      }
      String lastStation="";
      String stat;
      String dt;
      String temp;
      StringBuilder sb = new StringBuilder(1000);
      StringBuilder sb2 = new StringBuilder(1000);
      int nstat=0;
      int lcnt=0;
      int linecount=0;
      int stationsperline=10; // number of station names per line in display
      String [] line;
      sb2.delete(0,sb2.length());
      boolean filenameprinted ;
      boolean stopdisplay = false;
      boolean match;
      String regexp;
      String glob = globToRegex(regexpLog.getText());
      if(glob.indexOf("*") >= 0 || glob.indexOf("?") >=0) {
        regexp = globToRegex(glob);
      } 
      else {
        regexp = "";
      }      


      
      // for each member of the selected set, see if all of the parameters are set the 
      // same by calling chkParm for each value.  the parameter check must be initialized
      // to -1 to start.
      while (rs.next()) {
        if (filewrite){
          // write record to file
          stat = rs.getString("station");
          dt   = rs.getString("date");
          String fn =dt+"_"+stat;
          stat = Util.rightPad(stat,8).toString();
          temp = rs.getString(3);          
          PrintStream fileout = null;
          try {

            fileout = new PrintStream(new FileOutputStream(fn));
          }
            catch (FileNotFoundException e)   
          {
            System.err.println ("Error writing to file"+e.getMessage());
            System.exit(1);
          }
          fileout.print(temp);
          fileout.close();
        }
        else {
          stat = Util.rightPad(rs.getString("station"),8).toString();
          dt   = rs.getString("date");
          temp = rs.getString(3);
        }
        filenameprinted=false;
        line = temp.split("\n");
        for (int i= 0; i<line.length;i++){
          match=false;
          if(regexp.equals("") & line[i].indexOf(glob) >= 0) match=true;
          else if(line[i].matches(regexp)) match=true;
          if (match) {
             if (!filenameprinted){
               sb2.append("\n").append(stat).append("|").append(dt).append("|\n");
               filenameprinted=true;
             }  
             if (linecount>=10000){
               stopdisplay=true;
               linecount++;
             }
             else {
               sb2.append("  - ").append(line[i]).append("\n");
               linecount++;
             }
           }
        }
          
        if(stat.equals(lastStation)) {
          // Don't do anything - only want station listed once
        }
        else {
          nstat++;lcnt++;
          lastStation = stat;
          if(lcnt>=stationsperline) {
            sb.append(stat).append("\n");
            lcnt=0;
          }
          else {
            sb.append(stat);
          }
        } 
      }
      rs.close();
      sb.append("\nDisplaying logs from ").append(nstat).append(" stations\n");
//      error.setText("Displaying logs from "+nstat+" stations");
      addUpdate.setText("Read DB");
      stationnames.setText(sb.toString());
      if (stopdisplay) sb2.append("Stopped displaying lines at 10000");
      sb2.append(" -- Lines Found = ").append(linecount).append("\n");
      log.setText(sb2.toString());


    }
    catch (SQLException e) {
      stationnames.setText("SQL error getting channels\n"+e.getMessage()+"\n"+e.getErrorCode()+"\n"+e.getSQLState());
    }  
    filewrite=false;
  }
  /** The chkParms work this way.  User sets commID to -1 at beginning.  It then
   * calls chkParm(commID, i) where i is each succeeding value for a member of the 
   * selected set.  chkParms return -2 when parameters are found not to be set all the same
   * and the value when they are all set the same */
  private int chkParm(int commID, int i) {
    if(commID != -2) {
      if(commID == -1) commID=i;
      if(commID != i)  commID = -2;
    }
    return commID;
  }
  private String chkParm(String commID, String i) {
    if(!commID.equals("CHG") ) {
      if(commID.equals("")) commID=i;
      if(!commID.equals(i))  commID = "CHG";
    }
    return commID;
  }
  private long chkParm(long commID, long i) {
    if(commID != -2) {
      if(commID == -1) commID=i;
      if(commID != i)  commID = -2;
    }
    return commID;
  }
      
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton addUpdate;
  private javax.swing.JTextField datefrom;
  private javax.swing.JTextField dateto;
  private javax.swing.JTextField error;
  private javax.swing.JTextArea help;
  private javax.swing.JScrollPane jScrollPane;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JScrollPane jScrollPane2;
  private javax.swing.JLabel labRegexp;
  private javax.swing.JLabel lblDateFrom;
  private javax.swing.JLabel lblDateTo;
  private javax.swing.JLabel lblRegexpLog;
  private javax.swing.JTextArea log;
  private javax.swing.JTextField regexpLog;
  private javax.swing.JTextField regexpStation;
  private javax.swing.JTextPane stationnames;
  private javax.swing.JButton writefiles;
  // End of variables declaration//GEN-END:variables
    /** This main displays the form Pane by itself
   *@param args command line args ignored*/
  public static void main(String args[]) {
        DBConnectionThread jcjbl;
    Util.init(UC.getPropertyFilename());
    UC.init();
    try {
        // Make test DBconnection for form
      jcjbl = new DBConnectionThread(DBConnectionThread.getDBServer(),DBConnectionThread.getDBCatalog(),
              UC.defaultUser(),UC.defaultPassword(), true, false, DBConnectionThread.getDBSchema(), DBConnectionThread.getDBVendor());
      if(!DBConnectionThread.waitForConnection(DBConnectionThread.getDBSchema()))
        if(!DBConnectionThread.waitForConnection(DBConnectionThread.getDBSchema()))
          if(!DBConnectionThread.waitForConnection(DBConnectionThread.getDBSchema()))
          {Util.prt("Could not connect to DB "+jcjbl); System.exit(1);}
      Show.inFrame(new StatusLogRegexpPanel(), UC.XSIZE, UC.YSIZE);
    }
    catch(InstantiationException e) {}
  }
  
}
