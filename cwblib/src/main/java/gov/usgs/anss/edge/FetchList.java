/*
 * This software is in the public domain because it contains materials 
 * that originally came from the United States Geological Survey, 
 * an agency of the United States Department of Interior. For more 
 * information, see the official USGS copyright policy at 
 * http://www.usgs.gov/visual-id/credit_usgs.html#copyright
 */
package gov.usgs.anss.edge;

import gov.usgs.anss.util.Util;
import java.io.PrintStream;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.GregorianCalendar;

/**
 * This class contains the data for a FetchList entry usually representing some data that is missing
 * and needs to be acquired out-of-band of the realtime data. It is used in the gap generation and
 * fetching system.
 *
 * @author davidketchum
 */
public final class FetchList implements Comparable {

  private final String seedname;
  private String type;
  private final Timestamp start;
  private final int start_ms;
  private double duration;
  private final int ID;
  private double pga;
  private long updated;
  private long created;

  String status;

  @Override
  public int compareTo(Object o) {
    if (o == null) {
      return -1;
    }
    int i = seedname.compareTo(((FetchList) o).getSeedname());
    if (i != 0) {
      return i;
    }
    long t = ((FetchList) o).getStart().getTime() + ((FetchList) o).getStartMS();
    long mt = start.getTime() + start_ms;
    if (mt > t) {
      return 1;
    } else if (mt < t) {
      return -1;
    }
    return 0;
  }

  public boolean isSame(FetchList f) {
    if (Math.abs(f.getDuration() - duration) > 1.0) {
      if (duration < 10800.) {
        return false;
      }
    }
    if (!f.getType().equals(type)) {
      return false;
    }
    return Math.abs(f.getStart().getTime() + (long) f.getStartMS() - start.getTime() - start_ms) <= 1000;
  }

  public void setPGA(double a) {
    pga = a;
  }

  /**
   * Creates a new instance of FetchList
   *
   * @param seed The seedname of the full channel
   * @param st The start time to the nearest second of the start of fetch
   * @param ms The millis portion of the start time
   * @param dur The duration of the fetch is seconds
   * @param ty The 2 character fetch type
   * @param stat The fake status to use on this fetch entry.
   */
  public FetchList(String seed, Timestamp st, int ms, double dur, String ty, String stat) {
    seedname = seed;
    start = new Timestamp(st.getTime());
    start_ms = ms;
    duration = dur;
    type = ty;
    status = stat;
    ID = 0;
    updated = System.currentTimeMillis();
    created = updated;
  }

  /**
   * Creates a new instance of FetchList
   *
   * @param rs The result set to convert to a fetchlist object
   * @throws SQLException If one occurs reading the ResultSet
   */
  public FetchList(ResultSet rs) throws SQLException {
    ID = rs.getInt("ID");
    seedname = rs.getString("seedname");
    start = rs.getTimestamp("start");
    start_ms = rs.getInt("start_ms");
    start.setTime(start.getTime() / 1000L * 1000L);   // remove any fractions of a second
    duration = rs.getDouble("duration");
    type = rs.getString("type");
    status = rs.getString("status");
    updated = rs.getTimestamp("updated").getTime();
    created = rs.getTimestamp("created").getTime();
  }

  public int getID() {
    return ID;
  }

  public void setType(String t) {
    type = t;
  }

  public String getSeedname() {
    return seedname;
  }

  public long getUpdated() {
    return updated;
  }
  
  public long getCreated() {
    return created;
  }
  
  public String getType() {
    return type;
  }

  public String getStatus() {
    return status;
  }

  /**
   * get time stamp with time to the second. For the millis of a second call getStartMS()
   *
   * @return Timestamp with time to the second
   */
  public Timestamp getStart() {
    return start;
  }

  /**
   * Get millis of the second which cannot be stored in the timestamp start
   *
   * @return The millis of a second to add to the start to get exact time of request
   */
  public int getStartMS() {
    return start_ms;
  }

  public double getDuration() {
    return duration;
  }

  public void setStart(long ms) {
    start.setTime(ms);
  }

  public void setDuration(double d) {
    duration = d;
  }

  @Override
  public String toString() {
    return "Fetch : " + seedname + " " + start.toString().substring(0,19) + "." + start_ms + " dur=" + duration + " ty=" + type + " st=" + status + " pga=" + pga;
  }

  /**
   * given a RunList from a request, update this fetch list to be completed, and create any gaps
   * based on the runlist (beginning, end, or middle).
   *
   * @param runlistin A runlist of the blocks which were generated by this fetch being run
   * @param dbconn A JDBC Statement object to use to update the fetchlist (must be connected to edge
   * database)
   * @param table the table name
   * @param tag I logging tag for all log output
   * @param IOError If true, and IOError ended the fetch (do not make thinks nodata)
   * @param log The PrintStream to use for logging
   * @return true if something was updated.
   * @throws java.sql.SQLException If one occurs updating the fetchlist.
   */
  public boolean updateFetchWithRuns(RunList runlistin, Statement dbconn, String table,
          String tag, boolean IOError, PrintStream log) throws SQLException {

    runlistin.consolidate();
    GregorianCalendar g = new GregorianCalendar();
    ArrayList<Run> runsall = runlistin.getRuns();
    if (runsall.isEmpty()) {
      return false;        // usually the runs are 0. rate and all disappear
    }
    StringBuilder lastComp = runsall.get(0).getSeedname();
    log.println(Util.asctime() + " " + tag + " UpdateFetchWithRuns runslist \n" + runlistin.toString());

    // We need to break any multichannel run lists into multiple runlists with only one channel per runlist
    ArrayList<RunList> runlists = new ArrayList<>(3); // Holder of single channel runlists
    RunList tmp = new RunList(3);             // create a run list for the first channel
    runlists.add(tmp);                        // Put in on the sturcture of single channel runlists
    for (Run runsall1 : runsall) {
      // For each run in the original list
      if (Util.stringBuilderEqual(runsall1.getSeedname(), lastComp)) {
        // Is this the same channel
        tmp.add(runsall1); // yes, add the run to the runds list
      } else {
        // No, create a new RunList for this channel, addid and put Run in it
        lastComp = runsall1.getSeedname();
        tmp = new RunList(3);
        runlists.add(tmp);
        tmp.add(runsall1);
      }
    }

    // now run each of the single channel runslist
    for (RunList runlist : runlists) {
      ArrayList<Run> runs = runlist.getRuns();
      double rate = runlist.getRuns().get(0).getRate();
      int toleranceMS = 0;
      if(rate > 0) {
        toleranceMS = (int) Math.round(1000. / rate);
      }
      if(toleranceMS <= 0) {
        char band = runlist.get(0).getSeedname().charAt(7);
        toleranceMS = 10001;
        switch (band) {
          case 'V':
            toleranceMS=100000;
            break;
          case 'B':
          case 'S':
            toleranceMS = 100;
            break;
          case 'E':
          case 'H':
            toleranceMS = 10;
            break;
          case 'L':
            toleranceMS = 5000;
            break;
          case 'C':
          case 'D':
            toleranceMS = 4;
            break;
          default:
            toleranceMS = 1000;
            log.println(Util.asctime() + " " + tag +" ***** tolerance is unknown for channel ="+runlist.get(0).getSeedname()+" rt="+runlist.get(0).getRate());
        }
      }
      log.println(Util.asctime() + " " + tag + " UpdateFetchWithRuns single channel runslist rate="+
              runlist.getRuns().get(0).getRate()+" tolerance="+toleranceMS+" ms\n" + runlist.toString());
      Timestamp st2 = new Timestamp(start.getTime());
      if (st2.getTime() + start_ms + 1 >= runs.get(runs.size() - 1).getEnd() ) {
        if (System.currentTimeMillis() - st2.getTime() > 864000000L) {
          log.println(Util.asctime() + " " + tag + " **** fetch is entirely before runs and > 10 days old.  Mark no data");
          dbconn.executeUpdate("UPDATE " + table + " set status='nodata',updated=now() where ID=" + ID);// This fetch is done, but it may  generate some more
        } else {
          log.println(Util.asctime() + " " + tag + " **** fetch is entirely before the runs!  No action");
          dbconn.executeUpdate("UPDATE " + table + " set updated=now() where ID=" + ID);// This fetch is done, but it may  generate some more
        }
        return false;
      }
      
      if (st2.getTime() + duration * 1000. + start_ms -1 <= runs.get(0).getStart() - toleranceMS) {
        if (System.currentTimeMillis() - st2.getTime() > 864000000L) {
          log.println(Util.asctime() + " " + tag + " **** fetch is entirely after runs and > 10 days old.  Mark no data");
          dbconn.executeUpdate("UPDATE " + table + " set status='nodata',updated=now() where ID=" + ID);// This fetch is done, but it may  generate some more
        } else {
          log.println(Util.asctime() + " " + tag + " **** fetch is entirely after the runs!  No action");
           dbconn.executeUpdate("UPDATE " + table + " set updated=now() where ID=" + ID);// This fetch is done, but it may  generate some more
       }
        return false;
      }
      double newduration = runlist.secsOverlap(start.getTime()+ start_ms, duration) + .0004;
      log.println(Util.asctime() + " " + tag + " new duration for original gap ="+newduration+" id="+ID);
      dbconn.executeUpdate("UPDATE " + table + " set status='completed',duration=" + newduration + ",updated=now() where ID=" + ID);// This fetch is done, but it may  generate some more

      if (runs.get(0).getStart() - toleranceMS <= start.getTime() + start_ms
              && runs.get(0).getEnd() >= start.getTime() + (long) (duration * 1000) + start_ms) {
        log.println(Util.asctime() + " " + tag + " * Fetch fully completed " + seedname + " " + start + " dur=" + duration);
      } else {
        // There are gap as documented by the runs, create new fetchlist entries for these gaps.
        // Note : since the baler returns data only to nearest second, we need to be careful to make
        // sure the resulting beg or end gap is not actually the same gap, if so, it is a real never
        // to be recovered
        log.println(tag + runlist.toString());
        double dur;
        String s;
        String stts = "open";
        if (st2.getTime() + start_ms < runs.get(0).getStart() - toleranceMS) {    // There is a gap at the beginning
          dur = (runs.get(0).getStart() - st2.getTime() - 2) / 1000.;
          if (Math.abs(dur - duration) <= 1.0) {
            if (!IOError) {
              stts = "nodata";
            }
            log.println(Util.asctime() + " " + tag + " *** Beg Gap is the same.  " + seedname + " " + st2 + " dur=" + dur);
          }
          if (dur * 1000. > toleranceMS) {
            if(dur < 10.) {
              log.println(Util.asctime() + " " + tag + " * very small gap created dur="+dur);
            }
            dbconn.executeUpdate("INSERT INTO " + table + " (seedname,type,start,start_ms,duration,status,updated,created)"
                      + " VALUES ('" + seedname + "','" + type + "','" + st2.toString() + "','0',"
                      + dur + ",'" + stts + "',now(),now())");
          } else {
            log.println(Util.asctime() + " " + tag + "  **** gap too short - do not create new gap record="+dur);
          }
          log.println(Util.asctime() + " " + tag + " *** Beg Gap " + seedname + " " + st2 + " dur=" + dur + " status=" + stts);
        }
        if (runs.get(runs.size() - 1).getEnd() + 50 < start.getTime() + start_ms + (long) (duration * 1000)) {
          // the gap is from the end of the runs to the end of the fetch
          dur = (getStart().getTime() + start_ms + (long) (duration * 1000)
                  - runs.get(runs.size() - 1).getEnd() - 2) / 1000.;
          long ms = runs.get(runs.size() - 1).getEnd() + 1;
          g.setTimeInMillis(ms);
          stts = "open";
          if (Math.abs(g.getTimeInMillis() - start.getTime()) < 1000 && Math.abs(dur - duration) <= 1.) {
            if (!IOError) {
              stts = "nodata";
            }
            log.println(Util.asctime() + " " + tag + " **** End Gap is the same.  " + seedname + " "
                    + Util.ascdate(g) + " " + Util.asctime(g).substring(0, 8) + " dur=" + dur);
          }
          s = "INSERT INTO " + table + " (seedname,type,start, start_ms,duration,status,updated,created) VALUES ('"
                  + runs.get(0).getSeedname() + "','" + getType().trim() + "','"
                  + Util.ascdate(g) + " " + Util.asctime(g).substring(0, 8) + "',"
                  + (ms % 1000) + ","
                  + dur + ",'" + stts + "',now(),now())";
          if (dur > 0.051) {
            dbconn.executeUpdate(s);
          } else {
            log.println(Util.asctime() + " " + tag + "  **** gap too short - do not create new gap record");
          }
          log.println(Util.asctime() + " " + tag + " *** End Gap " + seedname + " "
                  + Util.ascdate(g) + " " + Util.asctime(g).substring(0, 8) + " " + (ms % 1000) + " dur=" + dur + " status=" + stts + " s=" + s);

        }
        // each run after the first describes a remaining gap and a new completed fetch
        for (int j = 1; j < runs.size(); j++) {
          s = "INSERT INTO " + table + " (seedname,type,start, start_ms,duration,status,updated,created) VALUES ('"
                  + runs.get(j).getSeedname() + "','" + getType().trim() + "','"
                  + Util.ascdate(runs.get(j).getStart()) + " " + Util.asctime(runs.get(j).getStart()).substring(0, 8) + "',"
                  + (runs.get(j).getStart() % 1000) + ","
                  + runs.get(j).getLength() + ",'completed',now(),now())";
          dbconn.executeUpdate(s);
          //Now the gap between this run and the prior one
          dur = (runs.get(j).getStart() - runs.get(j - 1).getEnd() - 2) / 1000.;
          g.setTimeInMillis(runs.get(j - 1).getEnd() + 1);
          stts = "open";
          if (Math.abs(dur - duration) <= 1.0) {
            if (!IOError) {
              stts = "nodata";
            }
            log.println(Util.asctime() + " " + tag + " **** mid gap is the same.  " + seedname + " " + Util.ascdate(g) + " "
                    + Util.asctime(g).substring(0, 8) + " dur=" + duration);
          }
          s = "INSERT INTO " + table + " (seedname,type,start, start_ms,duration,status,updated,created) VALUES ('"
                  + runs.get(j).getSeedname() + "','" + getType().trim() + "','"
                  + Util.ascdate(g) + " " + Util.asctime(g).substring(0, 8) + "',"
                  + (g.getTimeInMillis() % 1000) + ","
                  + dur + ",'" + stts + "',now(),now())";
          log.println(Util.asctime() + " " + tag + " *** Mid Gap " + seedname + " " + Util.ascdate(g) + " "
                  + Util.asctime(g).substring(0, 8) + " " + (g.getTimeInMillis() % 1000) + " dur=" + dur + " status=" + stts);
          if (dur > 0.050) {
            dbconn.executeUpdate(s);
          } else {
            log.println(Util.asctime() + " " + tag + "  **** gap too short - do not create new gap record");
          }

        }
      }   // End of else
    }
    return true;
  }
}
